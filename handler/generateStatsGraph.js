const {
  initialiseCanvas,
  drawText,
  drawBar,
  drawLine,
  drawLegend,
  formatNumber,
  drawRoundedRect,
} = require("../helper/canvas");

const COLORS = {
  background: "#1a1a2e",
  text: "#ffffff",
  textSecondary: "#a0a0a0",
  gridLine: "#333355",
  messages: "#4a9eff",
  reels: "#ff69b4",
  reactions: "#50fa7b",
  callHours: "#ffb347",
};

const MONTHS = [
  "Jan", "Feb", "Mar", "Apr", "May", "Jun",
  "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
];

const MONTHS_FULL = [
  "January", "February", "March", "April", "May", "June",
  "July", "August", "September", "October", "November", "December"
];

/**
 * Generate all-time summary image from aggregated monthly stats
 * Now works with pre-aggregated data instead of full message array
 */
const generateAllTimeSummary = (monthlyStats, startDate, endDate) => {
  const { canvas, ctx } = initialiseCanvas(1200, 800);

  // Background
  ctx.fillStyle = COLORS.background;
  ctx.fillRect(0, 0, 1200, 800);

  // Title
  drawText(ctx, "Message Statistics", 600, 60, "bold 36px Arial", COLORS.text, "center");

  // Date range
  const dateRange = `${formatDate(startDate)} - ${formatDate(endDate)}`;
  drawText(ctx, dateRange, 600, 100, "18px Arial", COLORS.textSecondary, "center");

  // Calculate totals from aggregated stats
  const stats = {
    messages: 0,
    reels: 0,
    reactions: 0,
    callMinutes: 0,
    callCount: 0,
    totalRecords: 0,
  };

  for (const key in monthlyStats) {
    const month = monthlyStats[key];
    stats.messages += month.messages;
    stats.reels += month.reels;
    stats.reactions += month.reactions;
    stats.callMinutes += month.callMinutes;
    stats.callCount += month.callCount;
    stats.totalRecords += month.messages + month.reels + month.reactions + month.callCount;
  }

  const callHours = Math.round(stats.callMinutes / 60);
  const callDays = Math.floor(callHours / 24);
  const remainingHours = callHours % 24;

  // Draw stat cards
  const cardWidth = 250;
  const cardHeight = 180;
  const cardY = 180;
  const gap = 40;
  const startX = (1200 - (cardWidth * 4 + gap * 3)) / 2;

  const cards = [
    { label: "Messages", value: stats.messages.toLocaleString(), color: COLORS.messages },
    { label: "Reels Shared", value: stats.reels.toLocaleString(), color: COLORS.reels },
    { label: "Reactions", value: stats.reactions.toLocaleString(), color: COLORS.reactions },
    { label: "Call Time", value: `${Math.round(callHours)} hours`, subtext: `(${callDays} days)`, color: COLORS.callHours },
  ];

  cards.forEach((card, i) => {
    const x = startX + i * (cardWidth + gap);

    // Card background
    drawRoundedRect(ctx, x, cardY, cardWidth, cardHeight, 12, "#2a2a4e");

    // Color accent bar at top
    ctx.fillStyle = card.color;
    ctx.fillRect(x + 20, cardY + 15, cardWidth - 40, 4);

    // Value
    drawText(ctx, card.value, x + cardWidth / 2, cardY + 90, "bold 42px Arial", COLORS.text, "center");

    // Subtext (for call time)
    if (card.subtext) {
      drawText(ctx, card.subtext, x + cardWidth / 2, cardY + 120, "16px Arial", COLORS.textSecondary, "center");
    }

    // Label
    drawText(ctx, card.label, x + cardWidth / 2, cardY + 155, "16px Arial", COLORS.textSecondary, "center");
  });

  // Additional stats row
  const row2Y = 420;
  drawText(ctx, "Additional Statistics", 600, row2Y, "bold 24px Arial", COLORS.text, "center");

  const avgCallLength = stats.callCount > 0 ? Math.round(stats.callMinutes / stats.callCount) : 0;

  const additionalStats = [
    { label: "Total Calls", value: stats.callCount.toLocaleString() },
    { label: "Avg Call Length", value: `${avgCallLength} min` },
    { label: "Total Records", value: stats.totalRecords.toLocaleString() },
  ];

  const smallCardWidth = 200;
  const smallStartX = (1200 - (smallCardWidth * 3 + gap * 2)) / 2;

  additionalStats.forEach((stat, i) => {
    const x = smallStartX + i * (smallCardWidth + gap);
    const y = row2Y + 40;

    drawRoundedRect(ctx, x, y, smallCardWidth, 100, 10, "#2a2a4e");
    drawText(ctx, stat.value, x + smallCardWidth / 2, y + 45, "bold 28px Arial", COLORS.text, "center");
    drawText(ctx, stat.label, x + smallCardWidth / 2, y + 75, "14px Arial", COLORS.textSecondary, "center");
  });

  // Footer
  drawText(ctx, "Generated by Trellis Statistics", 600, 760, "12px Arial", COLORS.textSecondary, "center");

  return canvas.toBuffer("image/png");
};

/**
 * Generate yearly bar chart from aggregated monthly stats
 * Now works with pre-aggregated data instead of full message array
 */
const generateYearlyBarChart = (monthlyStats, year) => {
  const { canvas, ctx } = initialiseCanvas(1200, 800);

  // Background
  ctx.fillStyle = COLORS.background;
  ctx.fillRect(0, 0, 1200, 800);

  // Title
  drawText(ctx, `${year} Monthly Breakdown`, 600, 50, "bold 32px Arial", COLORS.text, "center");

  // Get data for this year only
  const yearData = Object.values(monthlyStats).filter((s) => s.year === year);

  if (yearData.length === 0) {
    drawText(ctx, "No data for this year", 600, 400, "24px Arial", COLORS.textSecondary, "center");
    return canvas.toBuffer("image/png");
  }

  // Find max values for scaling
  const maxMessages = Math.max(...yearData.map((d) => d.messages), 1);
  const maxReels = Math.max(...yearData.map((d) => d.reels), 1);
  const maxReactions = Math.max(...yearData.map((d) => d.reactions), 1);
  const maxCallMinutes = Math.max(...yearData.map((d) => d.callMinutes), 1);

  // Normalize to same scale for visual comparison
  const maxValue = Math.max(maxMessages, maxReels, maxReactions, maxCallMinutes);

  // Chart dimensions
  const chartLeft = 80;
  const chartRight = 1120;
  const chartTop = 120;
  const chartBottom = 680;
  const chartHeight = chartBottom - chartTop;
  const chartWidth = chartRight - chartLeft;

  // Draw gridlines
  const gridLines = 5;
  for (let i = 0; i <= gridLines; i++) {
    const y = chartTop + (chartHeight / gridLines) * i;
    drawLine(ctx, chartLeft, y, chartRight, y, COLORS.gridLine);
    
    const value = Math.round(maxValue * (1 - i / gridLines));
    drawText(ctx, formatNumber(value), chartLeft - 10, y + 4, "12px Arial", COLORS.textSecondary, "right");
  }

  // Prepare month data (12 months)
  const months = Array.from({ length: 12 }, (_, i) => {
    const data = yearData.find((d) => d.month === i);
    return data || { month: i, messages: 0, reels: 0, reactions: 0, callMinutes: 0 };
  });

  // Bar dimensions
  const monthWidth = chartWidth / 12;
  const barWidth = 20;
  const barGap = 4;
  const groupWidth = barWidth * 4 + barGap * 3;

  // Draw bars for each month
  months.forEach((data, monthIndex) => {
    const monthX = chartLeft + monthIndex * monthWidth + monthWidth / 2;
    const groupStartX = monthX - groupWidth / 2;

    // Draw month label
    drawText(ctx, MONTHS[monthIndex], monthX, chartBottom + 25, "14px Arial", COLORS.text, "center");

    const metrics = [
      { value: data.messages, color: COLORS.messages },
      { value: data.reels, color: COLORS.reels },
      { value: data.reactions, color: COLORS.reactions },
      { value: data.callMinutes, color: COLORS.callHours },
    ];

    metrics.forEach((metric, i) => {
      const barHeight = (metric.value / maxValue) * chartHeight;
      const x = groupStartX + i * (barWidth + barGap);
      const y = chartBottom - barHeight;

      drawBar(ctx, x, y, barWidth, barHeight, metric.color);
    });
  });

  // Legend
  const legendItems = [
    { label: "Messages", color: COLORS.messages },
    { label: "Reels", color: COLORS.reels },
    { label: "Reactions", color: COLORS.reactions },
    { label: "Call Minutes", color: COLORS.callHours },
  ];
  drawLegend(ctx, legendItems, 360, 740, 150);

  // Year total summary at bottom
  const yearTotal = yearData.reduce(
    (acc, d) => ({
      messages: acc.messages + d.messages,
      reels: acc.reels + d.reels,
      reactions: acc.reactions + d.reactions,
      callMinutes: acc.callMinutes + d.callMinutes,
    }),
    { messages: 0, reels: 0, reactions: 0, callMinutes: 0 }
  );

  const summaryY = 85;
  const summaryText = `Total: ${yearTotal.messages.toLocaleString()} messages • ${yearTotal.reels.toLocaleString()} reels • ${yearTotal.reactions.toLocaleString()} reactions • ${Math.round(yearTotal.callMinutes / 60).toLocaleString()} call hours (${Math.round(yearTotal.callMinutes / 60 / 24).toLocaleString()} days) `;
  drawText(ctx, summaryText, 600, summaryY, "14px Arial", COLORS.textSecondary, "center");

  return canvas.toBuffer("image/png");
};

/**
 * Format date as DD/MM/YYYY
 */
const formatDate = (date) => {
  const day = date.getDate().toString().padStart(2, "0");
  const month = (date.getMonth() + 1).toString().padStart(2, "0");
  const year = date.getFullYear();
  return `${day}/${month}/${year}`;
};

// Legacy function kept for backwards compatibility
const generateStatsGraph = (monthlyStats) => {
  console.warn("generateStatsGraph is deprecated - use generateYearlyBarChart");
  return null;
};

// Legacy function - calculate monthly stats (now just returns the input since it's already aggregated)
const calculateMonthlyStats = (monthlyStats) => {
  // If it's already aggregated stats, just return it
  if (monthlyStats && !Array.isArray(monthlyStats)) {
    return monthlyStats;
  }
  // If somehow passed an array (legacy), warn and return empty
  console.warn("calculateMonthlyStats received legacy array format - this is deprecated");
  return {};
};

module.exports = {
  generateStatsGraph,
  generateAllTimeSummary,
  generateYearlyBarChart,
  calculateMonthlyStats,
};
